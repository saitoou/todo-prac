// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	Token *string `json:"token,omitempty"`
	User  *User   `json:"user,omitempty"`
}

// SignupRequest defines model for SignupRequest.
type SignupRequest struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Message string `json:"message"`
}

// Todo defines model for Todo.
type Todo struct {
	Content   *string    `json:"content,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *uint      `json:"id,omitempty"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	UserId    *int       `json:"user_id,omitempty"`
}

// TodoCreateRequest defines model for TodoCreateRequest.
type TodoCreateRequest struct {
	Content string `json:"content"`
	Title   string `json:"title"`
	UserId  uint   `json:"user_id"`
}

// TodoList defines model for TodoList.
type TodoList = []Todo

// TodoUpdateRequest defines model for TodoUpdateRequest.
type TodoUpdateRequest struct {
	Content string `json:"content"`
	Title   string `json:"title"`
}

// User defines model for User.
type User struct {
	Email *string `json:"email,omitempty"`
	Id    *int    `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// GetTodoListParams defines parameters for GetTodoList.
type GetTodoListParams struct {
	UserId *uint `form:"userId,omitempty" json:"userId,omitempty"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = LoginRequest

// PostAuthSignupJSONRequestBody defines body for PostAuthSignup for application/json ContentType.
type PostAuthSignupJSONRequestBody = SignupRequest

// CreateTodoJSONRequestBody defines body for CreateTodo for application/json ContentType.
type CreateTodoJSONRequestBody = TodoCreateRequest

// UpdateTodoJSONRequestBody defines body for UpdateTodo for application/json ContentType.
type UpdateTodoJSONRequestBody = TodoUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// ログイン
	// (POST /auth/login)
	PostAuthLogin(ctx echo.Context) error
	// ログアウト
	// (POST /auth/logout)
	PostAuthLogout(ctx echo.Context) error
	// ユーザー新規登録
	// (POST /auth/signup)
	PostAuthSignup(ctx echo.Context) error
	// タスク一覧取得
	// (GET /todos)
	GetTodoList(ctx echo.Context, params GetTodoListParams) error
	// タスク新規作成
	// (POST /todos)
	CreateTodo(ctx echo.Context) error
	// タスク削除
	// (DELETE /todos/{id})
	DeleteTodo(ctx echo.Context, id uint) error
	// タスク詳細取得
	// (GET /todos/{id})
	GetTodoByID(ctx echo.Context, id uint) error
	// タスク更新
	// (PUT /todos/{id})
	UpdateTodo(ctx echo.Context, id uint) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostAuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthLogin(ctx)
	return err
}

// PostAuthLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthLogout(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthLogout(ctx)
	return err
}

// PostAuthSignup converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSignup(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthSignup(ctx)
	return err
}

// GetTodoList converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodoList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTodoListParams
	// ------------- Optional query parameter "userId" -------------

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTodoList(ctx, params)
	return err
}

// CreateTodo converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTodo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTodo(ctx)
	return err
}

// DeleteTodo converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTodo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id uint

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTodo(ctx, id)
	return err
}

// GetTodoByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodoByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id uint

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTodoByID(ctx, id)
	return err
}

// UpdateTodo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTodo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id uint

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTodo(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/auth/login", wrapper.PostAuthLogin)
	router.POST(baseURL+"/auth/logout", wrapper.PostAuthLogout)
	router.POST(baseURL+"/auth/signup", wrapper.PostAuthSignup)
	router.GET(baseURL+"/todos", wrapper.GetTodoList)
	router.POST(baseURL+"/todos", wrapper.CreateTodo)
	router.DELETE(baseURL+"/todos/:id", wrapper.DeleteTodo)
	router.GET(baseURL+"/todos/:id", wrapper.GetTodoByID)
	router.PUT(baseURL+"/todos/:id", wrapper.UpdateTodo)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYXW8bRRT9K9aFxyXeQpAqvyWEIqOKRE0iHlBUTXdv7Cnemc3MbMBEluj6JVSt2pem",
	"qkCqBFEolaoGWqEiAvyYTdz0X6CZ8UfsHduhTUwq5W29Mzv3zjnnnrmeDQh4FHOGTEkobYAMqhgR8/ix",
	"EFxcQRlzJlG/iAWPUSiKZhj1sHn4mkRxDaEEEUpJKggeqHqsX0glKKtAo+GBwLWECgyh9EX705XuNH7t",
	"OgYKGh5c5hXKruBaglI5QkaE1vTDwPIexETKr7gIHYODsc0aR74YkcawrSv+JTJnHolEg8m7AlehBO8U",
	"e+gW29AWl/UcnVYu7CKtsCR+je0zEuEb4mKW8I4Hz2ISBCjlcIA6QngtdXTmuSIv8ZDnwwWcKWTKiUAg",
	"kCgMrxIzvMpFpJ8gJArfUzRypOMBDfvmJpSp3jTKFFY0gx4oqmpu3JM4/M9RtXau0qNUdUM1hkDxkdnc",
	"UMGMwmVE7r08xkEwwJxd0+vG7a01jMvL1OZNFUZyXOEY8ntQECFIvbPQsgH8RJEYsznXlpbb5X/cunWz",
	"PbSe8zJoeCAxSARV9UWNkg04i0SgmElUVf+6Zn5d6lD56edL4Fmf1yvZ0R63VaViaOiFKVs1tRaiDASN",
	"FeUMSjAfI5tZKBdWuSgszc/NF2YWylPQRbFvXPGQ63HwYB2FtAv4U/7UBb1JHiMjMYUSfDDlT/nGdFTV",
	"bKBIElUt1rQLGzi55VSDSnQe5RBKsMCl0ns0Zg2WLJRqlof1AcpJHNdoYL4sXpec9Q66cZLrO48a/ZJQ",
	"IkHzwrqgSfx93z/p2G2PNcH7qciaT7J0N0u3s+az1ubdg5sPNazT/oUTS6G/BXCkcPj49uGjvYPtX1v3",
	"7ls1JlFERH0gO60PUpG6jDSzsKKndknmiToWy3peDu/pvEQ7kX/M0p2suXl2oWknOAIdaTqC8ejYzuGU",
	"iqC/LTlWFZwczu1uySH+nay5l6W/Z829lw/+fHXrt6M8+5PjOWs+ztKnWfooS//Impv7L263nvyUI7yX",
	"bGtr93Dnjk3Zzby2TYNjBR2Uf4Kqe3JqyxQkQoVCL7IB2i9hLUFRh84pYs7gctjxfHKsc33lFH2tm70L",
	"zPQfDWP69PCXZy+f7068aJeZ5oEL+g2GNvj05IJ/xlXhEk+YifzhJDVcZgoFI7XCIop1FAXzwaCGO9Ts",
	"v/j2cOfngztbB3/fPyJgrVpY0f85nE5lW1XTwp2OS+X74Qk7lW1P8+Du//VDa/NuduNelt7Kbjzs4ngu",
	"7jMobuvOlrK8uLvuXNygYcN2HjVUmJf7nHnflvuASQ+xvPIceNbAdR/c828awqCM39DLT472wZsAB/wH",
	"39189WD7f2rCziU/XvKWIJeTj+o/ZutGr2dN2v6p2/l5i3L2JW2pGdGiJA5h2yuks2PZp9Mi9V+UTfhK",
	"Y1hNtb5/3traPW+R3o4WyZDlaI7MZaT+3lUzNR6QWgHZOhWcRchUIeZCFS76F33wIBG19t1jqVg0U6tc",
	"qpIZbaw0/g0AAP//FXkE76YaAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
